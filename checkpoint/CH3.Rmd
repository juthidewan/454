---
title: "STAT 454: Capstone 3"
author: Freddy Barragan, Juthi Dewan, Sam Ding, Vichy Meas
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: 
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
---

<style>
.list-group-item.active, .list-group-item.active:focus, .list-group-item.active:hover {
z-index: 2;
color: #FFFFFF;
background-color: #000000;
border-color: #000000;
}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(warning=FALSE, message=FALSE, 
                      fig.height = 4, fig.width = 7,
                      fig.align = 'center', fig.pos = 'H')
```


```{r}
# Load packages
library(here)
library(dplyr)
library(readr)
library(rstan)
library(bayesrules)
library(tidyverse)
library(bayesplot)
library(rstanarm)
library(janitor)
library(tidybayes)
library(broom.mixed)
library(here)
library(sf)
library(tidycensus)
library(openxlsx)
library(s2)
library(nycgeo)
library(CARBayes)
library(spData) 
library(spdep)

nyc_join <- merge(nta_sf,nta_acs_data)


nyc_join <- nyc_join %>%
  st_transform(., 4269)

county_list <- nyc_join %>% pull(county_name) %>% unique()


census_api_key("0cc07f06386e317f312adef5e0892b0d002b7254")

census_data <- get_acs(state = "NY", 
        county = c(county_list), 
        geography = "tract", 
        variables = c(gini_inequality ="B19083_001"),
        year = 2019,
        output = "wide",
        survey = "acs5",
        geometry = TRUE) %>% 
  dplyr::select(-c(NAME, ends_with("M"))) %>%
         rename_at(vars(ends_with("E")), .funs = list(~str_sub(., end = -2)))  %>%
  st_transform(., 4269) %>%
  dplyr::select(-GEOID)

```


```{r}
# themes
theme_set(theme_minimal())
vari_names <- read_csv(here("clean_data", "nyc_names.csv"))
nyc_clean <- st_read(here("clean_data", "nyc_data.shp"), crs = 4269, quiet=T) 
colnames(nyc_clean) <- colnames(vari_names)


library(openxlsx)
nta_to_census <- openxlsx::read.xlsx(here("ethnic", "Data", "census_to_nta.xlsx")) %>%
  dplyr::select(BoroName, NTACode) %>%
  rename(borough = BoroName,
         nta_id = NTACode) %>%
  unique()


nyc_clean <- nyc_clean %>%
  merge(., nta_to_census, by="nta_id") %>%
  mutate(transportation_desert_4cat = case_when(
    transportation_desert_4cat==1 ~ "Poor",
    transportation_desert_4cat ==2 ~ "Limited",
    transportation_desert_4cat ==3 ~ "Satisfactory",
    TRUE ~ "Excellent",
  ))  %>%
  mutate(transportation_desert_4cat = factor(transportation_desert_4cat, levels=c("Poor", "Limited", "Satisfactory", "Excellent")))


assault <- st_read("/Users/freddy/Downloads/NYPD Arrest Data (Year to Date)/geo_export_a659754f-6263-4ba1-8a58-72dca5befa79.shp") %>%
    filter(str_detect(ofns_desc, "FELONY ASSAULT"))  %>%
    filter(!(str_detect(ofns_desc, "POLICE")))  %>%
    filter(str_detect(pd_desc, "2") | str_detect(pd_desc, "1") ) %>%
  dplyr::select(arrest_key,geometry) %>%
  st_transform(., 4269)

sex <- st_read("/Users/freddy/Downloads/NYPD Arrest Data (Year to Date)/geo_export_a659754f-6263-4ba1-8a58-72dca5befa79.shp") %>%
    filter(str_detect(ofns_desc, "SEX"))  %>%
  dplyr::select(arrest_key,geometry) %>%
  st_transform(., 4269)

assault_neighborhood <- st_join(nyc_clean, assault, left = TRUE) %>%
  group_by(nta_id) %>%
  summarize(assault_count=n())  %>%
  as.tibble()


sex_neighborhood <- st_join(nyc_clean, sex,   left = TRUE) %>%
  group_by(nta_id) %>%
  summarize(sexcrime_count=n())  %>%
  as.tibble()


gini_neighborhood <- st_join(nyc_clean, census_data,left = TRUE) %>%
  group_by(nta_id) %>%
  summarize(gini_neighborhood=mean(gini_inequality, na.rm=T)) %>%
  as.tibble() %>%
  dplyr::select(nta_id, gini_neighborhood) 

assault_gini <- left_join(assault_neighborhood, gini_neighborhood,by="nta_id") %>%
  mutate(gini = gini_neighborhood, .before=3)%>%
  dplyr::select(-gini_neighborhood) %>%
  dplyr::select(-geometry)

sex_assault_gini <- left_join(assault_gini, sex_neighborhood,by="nta_id") %>%
  mutate(sex_crime_count = sexcrime_count, .before=3)%>%
  dplyr::select(-sexcrime_count) %>%
  dplyr::select(-geometry)


nyc_clean <- nyc_clean %>%
  as.tibble() %>%
  filter(nta_id %in% sex_assault_gini$nta_id) %>%
  left_join(., sex_assault_gini, by="nta_id")%>% 
  unique() %>%
  st_as_sf()
```

```{r}
subway_stations <- st_read(here("ethnic","Data","stations", "geo_export_85568705-efba-4456-bdc0-3d70ff2cf8e5.shp"), quiet=T)  %>%
  st_transform(., 4269)

bus_stations <- st_read(here("ethnic","Data","bus", "bus_stops_nyc_may2020.shp"), quiet=T)  %>%
  st_transform(., 4269)%>%
  filter(str_detect(NAMELSAD, "Richmond", negate=T))

transit_points <- read_csv(here("transit","ridership_points.csv"))%>%
  separate(Position, into=c("Point", "longitude", "latitude"), " ") %>%
  mutate(latitude = str_remove_all(latitude, "[)]"),
         longitude = str_remove_all(longitude, "[()]"),
         ) %>%
  dplyr::select(-c(Point)) %>% 
  mutate(latitude = as.numeric(latitude),
         longitude = as.numeric(longitude)) %>%
  st_as_sf(coords = c("longitude", "latitude"), crs = 4269)
```


```{r, fig.height=5*1.2, fig.width=5*1.2}
#plot locations over map
subway_loc <- ggplot() +
  geom_sf(data = nyc_clean, fill = "#EBF6FF", color = "#D48DD8", size = 0.15, alpha = .8) +
  geom_sf(data = subway_stations, color="#3F123C", size=1) + 
  coord_sf(datum = st_crs(subway_stations)) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Subway Stop Locations \nin NYC")+ 
    theme(#panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 30, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

bus_loc <- ggplot() +
  geom_sf(data = nyc_clean, fill = "#EBF6FF", color = "#D48DD8", size = 0.15, alpha = .8) +
  geom_sf(data = bus_stations, color="#3F123C", size=.5, alpha=.5) + 
  coord_sf(datum = st_crs(subway_stations)) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Bus Stop Locations \nin NYC")+ 
    theme(#panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 30, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))


stops <- nyc_clean %>%
  ggplot() +
  geom_sf(aes(fill = sub_count), color = "#8f98aa") +
  scale_fill_gradient(low= "lavender", high = "maroon",
                      guide = guide_legend(title = "Number of Subway Stops") ,na.value="#D6D6D6") +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Subway Stop Counts \nin NYC")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 30, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

bus_stops <- nyc_clean %>%
  ggplot() +
  geom_sf(aes(fill = bus_count), color = "#8f98aa") +
  scale_fill_gradient(low= "lavender", high = "maroon",
                      guide = guide_legend(title = "Number of Bus Stops") ,na.value="#D6D6D6") +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Bus Stop Counts \nin NYC")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 30, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))


ridership <- nyc_clean%>%
  ggplot() +
  geom_sf(aes(fill = log2(mean_ridership)), color = "#8f98aa") +
  scale_fill_gradient(low= "lavender", high = "maroon",
                      guide = guide_legend(title = "Log2 Mean Ridership") ,na.value="#D6D6D6") +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Mean (Log2) Subway Turnstile \nRidership in 2018 \nfor NYC")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 30, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

access <- nyc_clean %>%
  ggplot() +
  geom_sf(aes(fill = transportation_desert_4cat), color = "#8f98aa") +
  scale_fill_manual(values=c("#a45371","#e5b6c7","#ebebf7","#89a2d1"),
                       guide = guide_legend(title = "Subway Accessibility Category"), na.value="#D6D6D6") +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Subway Deserts \nin NYC")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 30, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```
`


```{r}
red <- ggplot(nyc_clean) +
  geom_sf(aes(fill = below_poverty_line_count), color = "#8f98aa") +
  scale_fill_gradient(low = "#FCF5EE", high = "#E13728", guide = guide_legend(title = "Number Below \nPoverty Line")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Impoverishement")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 26, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

yellow <- ggplot(nyc_clean) +
  geom_sf(aes(fill = mean_income), color = "#8f98aa") +
  scale_fill_gradient(low = "#FCF5EE", high = "#F3D24E", guide = guide_legend(title = "Mean Income")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Mean Income")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 26, face = "bold"),
          legend.title = element_text(size = 12),
          legend.text = element_text(size = 12)) +
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

teal <- ggplot(nyc_clean) +
  geom_sf(aes(fill = mean_rent), color = "#8f98aa") +
  scale_fill_gradient(low = "#FCF5EE", high = "#2DBDC7", guide = guide_legend(title = "Dollars")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Mean Rent")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 26, face = "bold"),
          legend.title = element_text(size = 12),
          legend.text = element_text(size = 12)) +
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

purple <- ggplot(nyc_clean) +
  geom_sf(aes(fill = eviction_count), color = "#8f98aa")+
  scale_fill_gradient(low = "#FCF5EE", high = "#7826C0", guide = guide_legend(title = "Number of Evictions")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Evictions")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 26, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

orange <- ggplot(nyc_clean) +
  geom_sf(aes(fill = unemployment_count), color = "#8f98aa")+
  scale_fill_gradient(low = "#FCF5EE", high = "#FC9228", guide = guide_legend(title = "Number on \nUnemployment")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Unemployment")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 26, face = "bold"),
          legend.title = element_text(size = 12),
          legend.text = element_text(size = 12)) +
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

green <- ggplot(nyc_clean) +
  geom_sf(aes(fill = store_count), color = "#8f98aa")+
  scale_fill_gradient(low = "#FCF5EE", high = "#326902", guide = guide_legend(title = "Number of Stores")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Retail Food Stores")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 26, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

blue <- ggplot(nyc_clean) +
  geom_sf(aes(fill = school_count), color = "#8f98aa")+
  scale_fill_gradient(low = "#FCF5EE", high = "#5372C4", 
                      guide = guide_legend(title = "Number of Schools")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Number of Schools")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 26, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

pink <- ggplot(nyc_clean) +
  geom_sf(aes(fill = uninsured_count), color = "#8f98aa")+
  scale_fill_gradient(low = "#FCF5EE", high = "#F450E1", guide = guide_legend(title = "Number of People \n without Insurance Coverage")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Insurance Coverage")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 26, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

navy <- nyc_clean %>%
  ggplot() +
  geom_sf(aes(fill = gini), color = "#8f98aa")+
  scale_fill_gradient(low = "#F8E3DD", high = "#16236f",
                      guide = guide_legend(title = "Gini Inequality Values"))+
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Income Inequality")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 25, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```

```{r}
white <- ggplot(nyc_clean) +
  geom_sf(aes(fill = white_count), color = "#8f98aa") +
  scale_fill_gradientn(colors = c("#FCF5EE","#BD9DA5", "#9C7080", "#7B435B"),  guide = guide_legend(title = "Number White")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("White Population")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

black <- ggplot(nyc_clean) +
  geom_sf(aes(fill = black_count), color = "#8f98aa") +
  scale_fill_gradientn(colors = c("#FCF5EE","#F8ABA6", "#F58581", "#F25F5C"), guide = guide_legend(title = "Number Black")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Black Population")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

asian <- ggplot(nyc_clean) +
  geom_sf(aes(fill = asian_count), color = "#8f98aa") +
  scale_fill_gradientn(colors = c("#FCF5EE","#B8BAD9", "#959CCE", "#717EC3"),                      guide = guide_legend(title = "Number Asian")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Asian Population")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

latinx <- ggplot(nyc_clean) +
  geom_sf(aes(fill = latinx_count), color = "#8f98aa")+
  scale_fill_gradientn(colors = c("#FCF5EE","#FDC894", "#FDB166", "#FC9A38"), 
                      guide = guide_legend(title = "Number Latinx")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Latinx Population")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

pop <- ggplot(nyc_clean) +
  geom_sf(aes(fill = total_pop), color = "#8f98aa")+
  scale_fill_gradientn(colors = c("#FCF5EE","#C0E3C3", "#A1D9AD", "#81CF97"), guide = guide_legend(title = "Number of People")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Total Population")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 26, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```



# Data Introduction

> All the data used in this project are from two major sources: the Tidycensus package and NYC Open Data. 
> 
> Tidycensus is an R  package interface, developed by Kyle Walker and Matt Herman, that enables easy access to the US Census Bureau’s data APIs and returns Tidyverse-ready data frames from various major US Census Bureau datasets. 
Our demographic and socioeconomic data are drawn from the American Community Survey results found in Tidycensus package. A summary of our ACS data variables is below:
>
- `borough:` Each Neighborhood's Borough.
- `total_pop`: Total Population by Neighborhood
- `mean_income`: Mean Income by Neighborhood
- `below_poverty_line_count`: Number of People Living Below the 100% Poverty Line by Neighborhood
- `mean_rent`:  Mean Rent by Neighborhood
-  `unemployment_count`: Number of People on Unemployment by Neighborhood
-  `latinx_count`: Number of Latinx People by Neighborhood
- `white_count`: Number of White People by Neighborhood
- `black_count`: Number of Black People by Neighborhood
- `native_count`: Number of Native People by Neighborhood
- `asian_count`: Number of Asian People by Neighborhood
- `naturalized_citizen_count`: Number of Naturalized Citizens by Neighborhood
- `noncitizen_count`: Number of Foreign Born People by Neighborhood 
- `uninsured_count`: Number of Uninsured Citizens of any Age by Neighborhood 
> 
> For remaining predictors, we used NYC Open Data's portal to identify specific predictors. In particular, we used geotagged locations of Subway Stops, Bus Stops, Grocery Stores, Schools, and Eviction Sites from the Departments of Transportation, Health, Education, and Housing to calculate neighborhood-specific variables described below: 
>
>
- `school_count`: Number of Public Schools by Neighborhood 
- `eviction_count`: Number of Evictions by Neighborhood 
- `store_count`: Number of Grocery Stores and Food Vendors by Neighborhood 
- `sub_count`: Number of Subway Stations by Neighborhood 
- `bus_count`: Number of Bus Stations by Neighborhood
- `perc_covered_by_transit`: Percent of Neighborhood Within Walking Distance (.25 miles) of Any Subway Stop. 
- `transportation_desert_4cat`: Subway Accessibility by Neighborhood (None, Limited, Satisfactory, Excellent)
>
> Lastly, we acquired subway ridership from Metropolitan Transportation Authority’s turnstile data for the week of September 7, 2019. For each station, entry/exit of each turnstile is recorded. Then, we aggregated this information by taking the station-specific average of subway ridership across the 7 days in the week. Finally, we geotagged each listed station, then took the mean of ridership at all subway stations in each neighborhood to create.
>
- `mean_ridership`: Mean Subway Ridership by Neighborhood for the week of September 7th.



\
\
\
\
\
\

# Data Summaries

> Our data has 224 observations of 26 variables. Below is a preview of our dataset with colnames attached.

```{r eval = TRUE}
library(kableExtra)
kable(head(nyc_clean, n=3)) %>% kable_styling() %>% scroll_box(width = "100%", height = "200px")
```

\
\

> Below is a numeric summary of each variable's distribution.

```{r eval = TRUE}
#summary(nyc_clean)
library(table1)
table_print <- table1(~ total_pop + mean_income + below_poverty_line_count+ 
         mean_rent + unemployment_count + white_count + uninsured_count + school_count + eviction_count + store_count + transportation_desert_4cat+ sub_count + bus_count + mean_ridership | borough, data = nyc_clean %>% as_tibble())  %>% as_tibble() 

colnames(table_print) <- c("Variable", "Bronx (N=44)", "Brooklyn (N=64)","Manhattan (N=39)", "Queens (N=77)", "Overall (N=224)")

table_print%>%
  filter(Variable!="") %>% kable() %>% kable_styling() %>% scroll_box(width = "100%", height = "500px")
```


\
\
\
\
\
\

# Data Visuals

## Non-Spatial {-}

```{r}
library(ggridges)
plot_1<-nyc_clean %>% 
  ggplot(aes(x=mean_income, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="Mean Income", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))

plot_2<-nyc_clean %>% 
  ggplot(aes(x=below_poverty_line_count, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="Number Below Poverty Line", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))

plot_3<-nyc_clean %>% 
  ggplot(aes(x=mean_rent, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="Mean Rent", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))

plot_4<-nyc_clean %>% 
  ggplot(aes(x=unemployment_count, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="Unemployed Counts", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))

plot_5<-nyc_clean %>% 
  ggplot(aes(x=white_count, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="White Counts", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))

plot_6<-nyc_clean %>% 
  ggplot(aes(x=uninsured_count, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="Uninsured Counts", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))


plot_7<-nyc_clean %>% 
  ggplot(aes(x=school_count, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="School Counts", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))

plot_8<-nyc_clean %>% 
  ggplot(aes(x=eviction_count, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="Eviction Counts", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))

plot_9<-nyc_clean %>% 
  ggplot(aes(x=store_count, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="Food Retail Counts", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))

plot_10<-nyc_clean %>% 
  ggplot(aes(x=borough, fill=transportation_desert_4cat), alpha=.6) +
  geom_bar(position="fill") +
  scale_y_continuous(labels = seq(0, 100, by = 25)) +
  labs(title="Subway Accessibility", y="", x="")+
    theme(panel.grid.major = element_line("transparent"),
         # axis.text.y.left = element_blank(),
          axis.text.x.bottom = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold")) +
   scale_fill_manual(values=c("#a45371","#e5b6c7","#ebebf7","#89a2d1"),
                       guide = guide_legend(title = "Subway Accessibility"), na.value="#D6D6D6") 

plot_11<-nyc_clean %>% 
  ggplot(aes(x=sub_count, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="Subway Stop Counts", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))


plot_12<-nyc_clean %>% 
  ggplot(aes(x=bus_count, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="Bus Stop Counts", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))

plot_13<-nyc_clean %>% 
  ggplot(aes(x=mean_ridership, y=borough, fill=borough), alpha=.6) +
  geom_density_ridges() +
  labs(title="Mean Ridership", y="")+
    theme(panel.grid.major = element_line("transparent"),
          axis.text.y.left = element_text(size = 16, face = "bold"),
          plot.title = element_text(size = 28,hjust=.5, face = "bold"),
          legend.position="none") +
  scale_fill_manual(values=c("#e09f3e","#16bac5","#717ec3","#5da271"))
```

```{r, fig.height=8*4, fig.width=8*4}
library(egg)
ggarrange(plot_1, plot_2, plot_3, 
          plot_4, plot_5, plot_6, 
          plot_7, plot_8, plot_9, plot_11, plot_12, 
          plot_13, plot_10,
          ncol=4)
```



## Spatial {-}

### Ridership {-}

```{r, fig.height=8*2, fig.width=8*3}
library(egg)
ggarrange(subway_loc, bus_loc, stops, bus_stops, ridership, access, ncol=3)
```

\
\

### Structural {-}

```{r, fig.height=8*3, fig.width=8*3}
ggarrange(red, orange, yellow, green, teal, blue, navy, purple, pink, ncol=3)
```


\
\


### Demographic {-}

```{r, fig.height=16, fig.width=16}
ggarrange(pop, white, black, latinx, asian, ncol=3)
```

### Crime

```{r, fig.height=16/3, fig.width=16/3}
nyc_clean %>%
ggplot() +
  geom_sf(aes(fill = sex_crime_count), color = "#8f98aa")+
  scale_fill_gradientn(colors=c("#fef6ef","#f07f9b","#e94a7c","#d61760"), guide = guide_legend(title = "Sex-Based Crime Counts")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("Sex-Based Violence")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 25, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```

```{r, fig.height=16/3, fig.width=16/3}
nyc_clean %>%
ggplot() +
  geom_sf(aes(fill = assault_count), color = "#8f98aa")+
  scale_fill_gradient(low = "#F8E3DD", high = "#95174F", guide = guide_legend(title = "Felony Assault Counts")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle("1st and 2nd Degree Felony \nAssault")+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 25, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```


\
\
\
\
\
\

# Demographics Models

## Models 1 & 2: Non-Hierarchical

> We use poisson and negative binomial regression to model observed white counts, $i$, using our $k=10$ predictors:
>
- mean_income
- mean_rent
- unemployment_count
- sub_count
- transportation_desert_4cat
- school_count
- store_count
- bus_count
- eviction_count
- uninsured_count
>
>

### Poisson {-}

$$\begin{split}
\text{White}_{i} \mid  \beta_{0}, \beta_1, ..., \beta_k & \sim \text{Pois}(\lambda_{i}) \; \; \; \; \text{where} \log(\lambda_{i}) = \beta_{0} + \sum^{10}_{k=1}X_{ik}\beta_k \\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
\end{split}$$

```{r}
poisson_non_hierarchical <- stan_glm(
  white_count ~ mean_income + mean_rent + 
    unemployment_count + 
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count,
  data = nyc_clean,
  family = poisson,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
```

```{r, fig.width=12, fig.height=6}
pp_check(poisson_non_hierarchical) + 
  xlab("White Resident Count") +
  labs(title = "Poisson")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

library(kableExtra)
nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_poisson <-  posterior_predict(
  poisson_non_hierarchical, newdata = nyc_predict_clean)

library(tidybayes)
library(bayesplot)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_poisson,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
  xaxis_text(angle = 90, hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(poisson_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8) %>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchical Poisson - Model Summary") %>% 
  kable_styling()
```

### Negative Binomial {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k, r & \sim \text{NegBin}(\mu_{ij}, r) \; \; \; \; \text{where} \log(\mu_{i}) = \beta_{0} + \sum^{11}_{k=1}X_{ik}\beta_k \\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
r & \sim Exp(1) \\
\end{split}$$

```{r, cache=TRUE}
negbin_non_hierarchical <- stan_glm(
  white_count ~  mean_income + mean_rent + 
    unemployment_count  + 
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count,
  data = nyc_clean,
  family = neg_binomial_2,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
  
```

```{r, fig.width=12, fig.height=6}
pp_check(negbin_non_hierarchical) + 
  xlab("White Resident Count") +
  
  labs(title = "Negative Binomial")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_negbin <-  posterior_predict(
  negbin_non_hierarchical, newdata = nyc_predict_clean)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_negbin,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
	xaxis_text(angle = 90,  hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())
tidy(negbin_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```


```{r}
table1 <- prediction_summary(model=poisson_non_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Poisson")
table2 <- prediction_summary(model=negbin_non_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Negative Binomial")
```

> Negative binomial has much better error metrics.


## Models 2 & 3: Hierarchy by Borough

> We use poisson and negative binomial hierarchical regression to model observed white counts, $i$, by boroughs $j$, usin our $k=11$ predictors. Note we are creating 3 dummy variables associated with `transportation_desert_4cat`:
>
- mean_income
- mean_rent
- unemployment_count
- transportation_desert_4cat
- school_count
- store_count
- bus_count
- eviction_count
- uninsured_count
>
>

### Poisson {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k & \sim \text{Pois}(\lambda_{ij}) \\
& \text{where} \log(\lambda_{ij}) = \beta_{0j} + \sum^{11}_{k=1}X_{ijk}\beta_k \\
\beta_{0j} \mid \beta_0, \sigma_0 & \stackrel{ind}{\sim} N(\beta_0, \sigma_0^2)\\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
\sigma_0 & \sim Exp(1)
\end{split}$$

```{r}
poisson_hierarchical <- stan_glmer(
 white_count ~ mean_income + mean_rent + 
    unemployment_count  + 
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count + (1 | borough),
  data = nyc_clean,
  family = poisson,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
```

```{r, fig.width=12, fig.height=6}
pp_check(poisson_hierarchical) + 
  xlab("White Resident Count") +
  labs(title = "Poisson")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

library(kableExtra)

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_poisson <-  posterior_predict(
  poisson_hierarchical, newdata = nyc_predict_clean)

library(tidybayes)
library(bayesplot)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_poisson,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
  xaxis_text(angle = 90, hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(poisson_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8) %>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Hierarchicahl Poisson - Model Summary") %>% 
  kable_styling()

```

### Negative Binomial {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k, r & \sim \text{NegBin}(\mu_{ij}, r) \\
& \text{where} \log(\mu_{ij}) = \beta_{0j} + \sum^{11}_{k=1}X_{ijk}\beta_k \\
\beta_{0j} \mid \beta_0, \sigma_0 & \stackrel{ind}{\sim} N(\beta_0, \sigma_0^2)\\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
r & \sim Exp(1) \\
\sigma_0 & \sim Exp(1)
\end{split}$$

```{r,  cache=TRUE}
negbin_hierarchical <- stan_glmer(
 white_count ~ mean_income + mean_rent + 
    unemployment_count + 
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count + (1 | borough),
  data = nyc_clean,
  family = neg_binomial_2,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0)
```

```{r, fig.width=12, fig.height=6}
pp_check(negbin_hierarchical) + 
  xlab("White Resident Count") +
  labs(title = "Negative Binomial")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_negbin <-  posterior_predict(
  negbin_hierarchical, newdata = nyc_predict_clean)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_negbin,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
	xaxis_text(angle = 90,  hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(negbin_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```


## Models 4 & 5: Spatial

```{r}
draft <- nyc_clean %>% drop_na(mean_rent) %>% drop_na(mean_income) %>% st_as_sf()
col_sp <- as(draft, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure
moran.mc(col_sp$white_count, listw = col_listw, nsim = 999, alternative = "greater")
```

### Poisson

```{r, fig.height=8, fig.width=8}
col_sp <- as(draft, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure

M.burnin <- 10000       # Number of burn-in iterations (discarded)
M <- 1000               # Number of iterations retained


model.assault <- S.CARleroux(
  white_count ~ 1 + gini  + 
    mean_income + mean_rent + 
    unemployment_count  + 
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count, 
  data = draft, 
  family = "poisson",
  W = W,
  burnin = M.burnin,
  n.sample = M.burnin + M,    # Total iterations
  verbose = FALSE)

as.data.frame(model.assault$summary.results) %>% 
  rownames_to_column("term") %>%
  kable()%>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "200px")

  
p_plot <- round((moran.mc(x = as.vector(model.assault$residuals$response), listw = col_listw, nsim = 9999, alternative = "greater")$p.value),5)
  

draft %>%
  mutate(resid = model.assault$residuals$response) %>%
  ggplot(aes(fill = resid), color = "#8f98aa") +
  geom_sf()+
  scale_fill_gradientn(colors=c("#fef6ef","#f07f9b","#e94a7c","#d61760"), guide =
                         guide_legend(title = "Residual")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle(paste0("1st and Degree Felony Assault: \nPoisson Model Residuals (", p_plot, ")"))+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 25, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```




### Zero-Inflated Poisson (Negative Binomial)

```{r, fig.height=8, fig.width=8}
col_sp <- as(draft, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure

M.burnin <- 10000       # Number of burn-in iterations (discarded)
M <- 1000               # Number of iterations retained


model.assault <- S.CARleroux(
  white_count ~ 1 + gini  + 
    mean_income + mean_rent + 
    unemployment_count  + 
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count, 
  data=draft,
  family = "zip",
  formula.omega = ~1,
  W = W,
  burnin = M.burnin,
  n.sample = M.burnin + M,    # Total iterations
  verbose = FALSE)

as.data.frame(model.assault$summary.results) %>% 
  rownames_to_column("term") %>%
  kable()%>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "200px")

  
p_plot <- round((moran.mc(x = as.vector(model.assault$residuals$response), listw = col_listw, nsim = 9999, alternative = "greater")$p.value),5)
  

draft %>%
  mutate(resid = model.assault$residuals$response) %>%
  ggplot(aes(fill = resid), color = "#8f98aa") +
  geom_sf()+
  scale_fill_gradientn(colors=c("#fef6ef","#f07f9b","#e94a7c","#d61760"), guide =
                         guide_legend(title = "Residual")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle(paste0("1st and Degree Felony Assault: \nZIP Model Residuals (", p_plot, ")"))+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 25, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```












## Comparison

```{r}
table3 <- prediction_summary(model=poisson_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Hierarchichal Poisson")
table4 <- prediction_summary(model=negbin_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Hierarchichal Negative Binomial") 

rbind(table1, table2, table3, table4) %>%
  dplyr::mutate(model = Model, .before=1) %>%
  dplyr::select(-Model)%>% kable() %>% kable_styling()
```

Using in-sample scaled MAE, it's evident our negative binomial regression models, regardless of hierarchy, performed better than our poisson regression models. However, the differences between the two negative binomial models was neglible. So, we will more closely interpret the non-hierarchichal negative binomial regression model.

```{r}
tidy(negbin_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```

>After removing predictors whose 95% credible intervals included the possibility of non-effect when controlling for other covariates, we found that there were 6 remaining predictors of an arbitrary neighborhood's white population count:
>
- Mean income by neighborhood
- Unemployment counts by neighborhood
- Transportation desert status by neighborhood
- Food Vendor counts by neighborhood
- Bus station counts by neighborhood
- Eviction counts by neighborhood.
>
Next, we interpret each predictor:
>
- Mean Income: When controlling for all other predictors, 1 dollar increases in mean neighborhood rental prices are associated with approximately 0.00143% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.000330%, 0.00268%), indicating that there is almost certainly a negative relationship between these two variables, but its magnitude may vary.
- Unemployment Count: When controlling for all other predictors, 1 dollar increases in unemployed people counts by neighborhood are associated with approximately 0.0493% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.0140%, 0.0790%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Limited Subway Access: When controlling for all other predictors, a neighborhood with limited access to subway transit is expected to have approximately 125.753% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (51.508%, 269.541%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Satisfactory Subway Access: When controlling for all other predictors, a neighborhood with satisfactory access to subway transit is expected to have approximately 136.342% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (44.081%, 282.669%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Excellent Subway Access: When controlling for all other predictors, a neighborhood with excellent access to subway transit is expected to have approximately 98.186% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (15.762%, 275.969%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Food Vendor Count: When controlling for all other predictors, 1 store increases in the number of food vendors by neighborhood are associated with approximately 0.759% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.261%, 1.469%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Bus Stop Count: When controlling for all other predictors, 1 stop increases in the number of bus stop by neighborhood are associated with approximately 0.6516973% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.0402706%, 1.1496164%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Eviction Count: When controlling for all other predictors, increases in the number of evictions by neighborhood are associated with approximately 0.340% decreases in the white population count. However, there is a 95% chance that the relationship may be any value between (-0.425%, -0.248%), indicating that there is almost certainly a negative relationship between these two variables, but its magnitude may vary.
>
> If we intended to essentialize this list, `transportation_desert_4`, `eviction_count`, `store_count` seem to be the most informative predictors.

# Transportation Models

## Naive Bayes
```{r}
# Load the package
library(e1071)

# Run the algorithm using only data on bill length
naive_model_1 <- naiveBayes(transportation_desert_4cat ~ mean_income + mean_rent + unemployment_count + school_count + store_count + bus_count + eviction_count + uninsured_count + white_count+ black_count+ latinx_count + asian_count, data = nyc_clean)
```

### Classifications {-}

#### Racial Counts

```{r}
grid_data <- expand_grid(
    black_count = seq(min((nyc_clean %>% drop_na(black_count))$black_count), max((nyc_clean %>% drop_na(black_count))$black_count), length = 100),
    white_count = seq(min((nyc_clean %>% drop_na(white_count))$white_count), max((nyc_clean %>% drop_na(white_count))$white_count), length = 100)) %>%
  mutate(classification = predict(naive_model_1, newdata = .))

# Plot the classification regions
plot_1 <- ggplot(grid_data, aes(x = black_count, y = white_count, color = classification)) +
  geom_point(alpha = 1, size=1.5) +
  scale_color_manual(values=c("#a45371","#e5b6c7","#ebebf7","#89a2d1"),
                       guide = guide_legend(title = "Subway Accessibility"), na.value="#D6D6D6")  +
  theme_minimal() +
  ggtitle("Black and White Population") +
  labs(x="Black Count", y="White Count", color="Subway Accessibility")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, hjust=.5, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```

```{r}
grid_data <- expand_grid(
    latinx_count = seq(min((nyc_clean %>% drop_na(latinx_count))$latinx_count), max((nyc_clean %>% drop_na(latinx_count))$latinx_count), length = 100),
    white_count = seq(min((nyc_clean %>% drop_na(white_count))$white_count), max((nyc_clean %>% drop_na(white_count))$white_count), length = 100)) %>%
  mutate(classification = predict(naive_model_1, newdata = .))

# Plot the classification regions
plot_2 <- ggplot(grid_data, aes(x = latinx_count, y = white_count, color = classification)) +
  geom_point(alpha = 1, size=1.5) +
  scale_color_manual(values=c("#a45371","#e5b6c7","#ebebf7","#89a2d1"),
                       guide = guide_legend(title = "Subway Accessibility"), na.value="#D6D6D6")  +
  theme_minimal() +
  ggtitle("Latinx and White Population") +
  labs(x="Latinx Count", y="White Count", color="Subway Accessibility")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, hjust=.5, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

grid_data <- expand_grid(
    asian_count = seq(min((nyc_clean %>% drop_na(asian_count))$asian_count), max((nyc_clean %>% drop_na(asian_count))$asian_count), length = 100),
    white_count = seq(min((nyc_clean %>% drop_na(white_count))$white_count), max((nyc_clean %>% drop_na(white_count))$white_count), length = 100)) %>%
  mutate(classification = predict(naive_model_1, newdata = .))

# Plot the classification regions
plot_3 <- ggplot(grid_data, aes(x = asian_count, y = white_count, color = classification)) +
  geom_point(alpha = 1, size=1.5) +
  scale_color_manual(values=c("#a45371","#e5b6c7","#ebebf7","#89a2d1"),
                       guide = guide_legend(title = "Subway Accessibility"), na.value="#D6D6D6")  +
  theme_minimal() +
  ggtitle("Asian and White Population") +
  labs(x="Asian Count", y="White Count", color="Subway Accessibility")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, hjust=.5, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```

```{r, fig.height=8, fig.width=24}
ggpubr::ggarrange(plot_1, plot_2, plot_3, ncol=3,nrow = 1, common.legend=TRUE, legend = "bottom")
```

#### Mean Income by Racial Counts

```{r}
grid_data <- expand_grid(
    mean_income = seq(min((nyc_clean %>% drop_na(mean_income))$mean_income), max((nyc_clean %>% drop_na(mean_income))$mean_income), length = 100),
    white_count = seq(min((nyc_clean %>% drop_na(white_count))$white_count), max((nyc_clean %>% drop_na(white_count))$white_count), length = 100)) %>%
  mutate(classification = predict(naive_model_1, newdata = .))

# Plot the classification regions
white <- ggplot(grid_data, aes(x = mean_income, y = white_count, color = classification)) +
  geom_point(alpha = 1, size=1.5) +
  scale_color_manual(values=c("#a45371","#e5b6c7","#ebebf7","#89a2d1"),
                       guide = guide_legend(title = "Subway Accessibility"), na.value="#D6D6D6")  +
  theme_minimal() +
  ggtitle("White Population") +
  labs(x="Mean Neighborhood Income", y="Count", color="Subway Accessibility")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, hjust=.5, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

grid_data <- expand_grid(
    mean_income = seq(min((nyc_clean %>% drop_na(mean_income))$mean_income), max((nyc_clean %>% drop_na(mean_income))$mean_income), length = 100),
    black_count = seq(min((nyc_clean %>% drop_na(black_count))$black_count), max((nyc_clean %>% drop_na(black_count))$black_count), length = 100)) %>%
  mutate(classification = predict(naive_model_1, newdata = .))

black <-ggplot(grid_data, aes(x = mean_income, y = black_count, color = classification)) +
  geom_point(alpha = 1, size=1.5) +
  scale_color_manual(values=c("#a45371","#e5b6c7","#ebebf7","#89a2d1"),
                       guide = guide_legend(title = "Subway Accessibility"), na.value="#D6D6D6")  +
  ggtitle("Black Population")+ 
  labs(x="Mean Neighborhood Income", y="Count", color="Subway Accessibility")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, hjust=.5, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

grid_data <- expand_grid(
    mean_income = seq(min((nyc_clean %>% drop_na(mean_income))$mean_income), max((nyc_clean %>% drop_na(mean_income))$mean_income), length = 100),
    latinx_count = seq(min((nyc_clean %>% drop_na(latinx_count))$latinx_count), max((nyc_clean %>% drop_na(latinx_count))$latinx_count), length = 100)) %>%
  mutate(classification = predict(naive_model_1, newdata = .))

latinx<-ggplot(grid_data, aes(x = mean_income, y = latinx_count, color = classification)) +
  geom_point(alpha = 1, size=1.5) +
  scale_color_manual(values=c("#a45371","#e5b6c7","#ebebf7","#89a2d1"),
                       guide = guide_legend(title = "Subway Accessibility"), na.value="#D6D6D6")  +
  theme_minimal() +
  ggtitle("Latinx Population")  +
  labs(x="Mean Neighborhood Income", y="Count", color="Subway Accessibility")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, hjust=.5, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

grid_data <- expand_grid(
    mean_income = seq(min((nyc_clean %>% drop_na(mean_income))$mean_income), max((nyc_clean %>% drop_na(mean_income))$mean_income), length = 100),
    asian_count = seq(min((nyc_clean %>% drop_na(asian_count))$asian_count), max((nyc_clean %>% drop_na(asian_count))$asian_count), length = 100)) %>%
  mutate(classification = predict(naive_model_1, newdata = .))

asian <- ggplot(grid_data, aes(x = mean_income, y = asian_count, color = classification)) +
  geom_point(alpha = 1, size=1.5) +
  scale_color_manual(values=c("#a45371","#e5b6c7","#ebebf7","#89a2d1"),
                       guide = guide_legend(title = "Subway Accessibility"), na.value="#D6D6D6")  +
  ggtitle("Asian Population")+ 
  labs(x="Mean Neighborhood Income", y="Count", color="Subway Accessibility")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, hjust=.5, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```


```{r, fig.height=8*2, fig.width=16}

ggpubr::ggarrange(white, black, latinx, asian, ncol=2,nrow = 2, common.legend=TRUE, legend = "bottom", label.x = )
```

#### Mean Income by Mean Rent 
```{r, fig.height=4, fig.width=8}
grid_data <- expand_grid(
    mean_income = seq(min((nyc_clean %>% drop_na(mean_income))$mean_income), max((nyc_clean %>% drop_na(mean_income))$mean_income), length = 100),
    mean_rent = seq(min((nyc_clean %>% drop_na(mean_rent))$mean_rent), max((nyc_clean %>% drop_na(mean_rent))$mean_rent), length = 100)) %>%
  mutate(classification = predict(naive_model_1, newdata = .))

# Plot the classification regions

ggplot(grid_data, aes(x = mean_income, y = mean_rent, color = classification)) +
  geom_point(alpha = 1, size=1) +
  scale_color_manual(values=c("#a45371","#e5b6c7","#ebebf7","#89a2d1"),
                       guide = guide_legend(title = "Subway Accessibility"), na.value="#D6D6D6")  +
  theme_minimal() +
  ggtitle("Mean Rental Price") +
  labs(x="Mean Neighborhood Income", y="Mean Neighborhood Rental Price", color="Subway Accessibility")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, hjust=.5, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```


takeaways:

1) high income + high white count ~ Excellent Access
2) low-mid white count + low mean income ~ satisfactory access
3) low-mid white + low-mid mean income ~ Limited access
4) low white count + low-mid mean income ~ no access

\
\
\
\
\
\


#### Unemployment by Eviction Counts
```{r, fig.height=4, fig.width=8}
grid_data <- expand_grid(
    unemployment_count = seq(min((nyc_clean %>% drop_na(unemployment_count))$unemployment_count), max((nyc_clean %>% drop_na(unemployment_count))$unemployment_count), length = 100),
    eviction_count = seq(min((nyc_clean %>% drop_na(eviction_count))$eviction_count), max((nyc_clean %>% drop_na(eviction_count))$eviction_count), length = 100)) %>%
  mutate(classification = predict(naive_model_1, newdata = .))

# Plot the classification regions
ggplot(grid_data, aes(x = unemployment_count, y = eviction_count, color = classification)) +
  geom_point(alpha = 1, size=1) +
  scale_color_manual(values=c("#a45371","#e5b6c7","#ebebf7","#89a2d1"),
                       guide = guide_legend(title = "Subway Accessibility"), na.value="#D6D6D6")  +
  theme_minimal() +
  ggtitle("Eviction by Unemployment Counts") +
  labs(x="Unemployment Count", y="Eviction Count", color="Subway Accessibility")+
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 24, hjust=.5, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))
```


takeaways:

1) high income + high white count ~ Excellent Access
2) low-mid white count + low mean income ~ satisfactory access
3) low-mid white + low-mid mean income ~ Limited access
4) low white count + low-mid mean income ~ no access

\
\
\
\
\
\


# Eviction Models
## Models 1 & 2: Non-Hierarchical

> We use poisson and negative binomial regression to model observed eviction counts, $i$, using our $k=10$ predictors:
>
- gini
- mean_income
- white_count
- black_count
- latinx_count
- asian_count
- mean_rent
- unemployment_count
- sub_count
- transportation_desert_4cat
- school_count
- store_count
- bus_count
- eviction_count
- uninsured_count
>
>

### Poisson {-}

$$\begin{split}
\text{White}_{i} \mid  \beta_{0}, \beta_1, ..., \beta_k & \sim \text{Pois}(\lambda_{i}) \; \; \; \; \text{where} \log(\lambda_{i}) = \beta_{0} + \sum^{10}_{k=1}X_{ik}\beta_k \\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
\end{split}$$

```{r}
poisson_non_hierarchical <- stan_glm(
  eviction_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    uninsured_count,
  data = nyc_clean,
  family = poisson,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
```

```{r, fig.width=12, fig.height=6}
pp_check(poisson_non_hierarchical) + 
  xlab("Eviction Count") +
  xlim(0,max(nyc_clean$eviction_count))+
  labs(title = "Poisson")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

library(kableExtra)
nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_poisson <-  posterior_predict(
  poisson_non_hierarchical, newdata = nyc_predict_clean)

library(tidybayes)
library(bayesplot)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_poisson,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
  xaxis_text(angle = 90, hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(poisson_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8) %>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchical Poisson - Model Summary") %>% 
  kable_styling()
```

### Negative Binomial {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k, r & \sim \text{NegBin}(\mu_{ij}, r) \; \; \; \; \text{where} \log(\mu_{i}) = \beta_{0} + \sum^{11}_{k=1}X_{ik}\beta_k \\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
r & \sim Exp(1) \\
\end{split}$$

```{r, cache=TRUE}
negbin_non_hierarchical <- stan_glm(
 eviction_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    uninsured_count,
  data = nyc_clean,
  family = neg_binomial_2,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
  
```

```{r, fig.width=12, fig.height=6}
pp_check(negbin_non_hierarchical) + 
  xlab("Eviction Count") +
  xlim(0,max(nyc_clean$eviction_count))+
  labs(title = "Negative Binomial")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_negbin <-  posterior_predict(
  negbin_non_hierarchical, newdata = nyc_predict_clean)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_negbin,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
	xaxis_text(angle = 90,  hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())
tidy(negbin_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```


```{r}
table1 <- prediction_summary(model=poisson_non_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Poisson")
table2 <- prediction_summary(model=negbin_non_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Negative Binomial")
```

> Negative binomial has much better error metrics.


## Models 2 & 3: Hierarchy by Borough

> We use poisson and negative binomial hierarchical regression to model observed white counts, $i$, by boroughs $j$, usin our $k=11$ predictors. Note we are creating 3 dummy variables associated with `transportation_desert_4cat`:
>
- mean_income
- mean_rent
- unemployment_count
- transportation_desert_4cat
- school_count
- store_count
- bus_count
- eviction_count
- uninsured_count
>
>

### Poisson {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k & \sim \text{Pois}(\lambda_{ij}) \\
& \text{where} \log(\lambda_{ij}) = \beta_{0j} + \sum^{11}_{k=1}X_{ijk}\beta_k \\
\beta_{0j} \mid \beta_0, \sigma_0 & \stackrel{ind}{\sim} N(\beta_0, \sigma_0^2)\\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
\sigma_0 & \sim Exp(1)
\end{split}$$

```{r}
poisson_hierarchical <- stan_glmer(
  eviction_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    uninsured_count + (1 | borough),
  data = nyc_clean,
  family = poisson,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
```

```{r, fig.width=12, fig.height=6}
pp_check(poisson_hierarchical) + 
  xlab("Eviction Count") +
  xlim(0,max(nyc_clean$eviction_count))+
  labs(title = "Poisson")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

library(kableExtra)

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_poisson <-  posterior_predict(
  poisson_hierarchical, newdata = nyc_predict_clean)

library(tidybayes)
library(bayesplot)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_poisson,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
  xaxis_text(angle = 90, hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(poisson_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8) %>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Hierarchicahl Poisson - Model Summary") %>% 
  kable_styling()

```

### Negative Binomial {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k, r & \sim \text{NegBin}(\mu_{ij}, r) \\
& \text{where} \log(\mu_{ij}) = \beta_{0j} + \sum^{11}_{k=1}X_{ijk}\beta_k \\
\beta_{0j} \mid \beta_0, \sigma_0 & \stackrel{ind}{\sim} N(\beta_0, \sigma_0^2)\\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
r & \sim Exp(1) \\
\sigma_0 & \sim Exp(1)
\end{split}$$

```{r,  cache=TRUE}
negbin_hierarchical <- stan_glmer(
eviction_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    uninsured_count+ (1 | borough),
  data = nyc_clean,
  family = neg_binomial_2,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0)
```

```{r, fig.width=12, fig.height=6}
pp_check(negbin_hierarchical) + 
  xlab("Eviction Count") +
  xlim(0,max(nyc_clean$eviction_count))+
  labs(title = "Negative Binomial")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_negbin <-  posterior_predict(
  negbin_hierarchical, newdata = nyc_predict_clean)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_negbin,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
	xaxis_text(angle = 90,  hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(negbin_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```


## Models 4 & 5: Spatial

```{r}
col_sp <- as(nyc_clean, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure
moran.mc(col_sp$eviction_count, listw = col_listw, nsim = 999, alternative = "greater")
```

### Poisson

```{r, fig.height=8, fig.width=8}
col_sp <- as(nyc_clean, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure

M.burnin <- 10000       # Number of burn-in iterations (discarded)
M <- 1000               # Number of iterations retained


model.eviction <- S.CARleroux(
  eviction_count ~ 1 + gini  + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count +  uninsured_count, 
  data = nyc_clean, 
  family = "poisson",
  W = W,
  burnin = M.burnin,
  n.sample = M.burnin + M,    # Total iterations
  verbose = FALSE)

as.data.frame(model.eviction$summary.results) %>% 
  rownames_to_column("term") %>%
  kable()%>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "200px")

  
p_plot <- round((moran.mc(x = as.vector(model.eviction$residuals$response), listw = col_listw, nsim = 9999, alternative = "greater")$p.value),5)
  

nyc_clean %>%
  mutate(resid = model.eviction$residuals$response) %>%
  ggplot(aes(fill = resid), color = "#8f98aa") +
  geom_sf()+
  scale_fill_gradientn(colors=c("#fef6ef","#f07f9b","#e94a7c","#d61760"), guide =
                         guide_legend(title = "Residual")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle(paste0("Eviction: \nPoisson Model Residuals (", p_plot, ")"))+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 25, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))


```




### Zero-Inflated Poisson (Negative Binomial)

```{r, fig.height=8, fig.width=8}
draft <- nyc_clean

col_sp <- as(draft, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure

M.burnin <- 10000       # Number of burn-in iterations (discarded)
M <- 1000               # Number of iterations retained

model.eviction <- S.CARleroux(
  eviction_count ~ 1 + gini  + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count +  uninsured_count, 
  data = nyc_clean, 
  family = "zip",
  formula.omega = ~1,
  W = W,
  burnin = M.burnin,
  n.sample = M.burnin + M,    # Total iterations
  verbose = FALSE)

as.data.frame(model.eviction$summary.results) %>% 
  rownames_to_column("term") %>%
  filter(Median != 0 ) %>%
  filter(`2.5%`	> 0 & `97.5%` > 0 | `2.5%`	< 0 & `97.5%` < 0) %>%  
  kable()%>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "200px")

  
# p_plot <- round((moran.mc(x = as.vector(model.eviction$residuals$response), listw = col_listw, nsim = 9999, alternative = "greater")$p.value),5)


 nyc_clean %>%
   mutate(resid = model.eviction$residuals$response) %>%
   ggplot(aes(fill = resid), color = "#8f98aa") +
   geom_sf()+
   scale_fill_gradientn(colors=c("#fef6ef","#f07f9b","#e94a7c","#d61760"), guide =
                          guide_legend(title = "Residual")) +
   theme_minimal() +
   theme(panel.grid.major = element_line("transparent"),
         axis.text = element_blank()) +
   ggtitle(paste0("Eviction: \nZIP Model Residuals ( p_plot)"))+
     theme(panel.grid.major = element_line("transparent"),
           plot.title = element_text(size = 25, face = "bold"),
           legend.title = element_text(size = 12),
           legend.text = element_text(size = 12)) +
     guides(shape = guide_legend(override.aes = list(size = 8)),
            color = guide_legend(override.aes = list(size = 8)))

```







## Comparison

```{r}
table3 <- prediction_summary(model=poisson_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Hierarchichal Poisson")
table4 <- prediction_summary(model=negbin_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Hierarchichal Negative Binomial") 

rbind(table1, table2, table3, table4) %>%
  dplyr::mutate(model = Model, .before=1) %>%
  dplyr::select(-Model)%>% kable() %>% kable_styling()
```

> Using in-sample scaled MAE, it's evident our negative binomial regression models, regardless of hierarchy, performed better than our poisson regression models. However, the differences between the two negative binomial models was neglible. So, we will more closely interpret the non-hierarchichal negative binomial regression model.

```{r}
tidy(negbin_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```

>After removing predictors whose 95% credible intervals included the possibility of non-effect when controlling for other covariates, we found that there were 6 remaining predictors of an arbitrary neighborhood's felony eviction counts:
>
- Mean income by neighborhood
- Unemployment counts by neighborhood
- Transportation desert status by neighborhood
- Food Vendor counts by neighborhood
- Bus station counts by neighborhood
- Eviction counts by neighborhood.
>
Next, we interpret each predictor:
>
- Mean Income: When controlling for all other predictors, 1 dollar increases in mean neighborhood rental prices are associated with approximately 0.00143% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.000330%, 0.00268%), indicating that there is almost certainly a negative relationship between these two variables, but its magnitude may vary.
- Unemployment Count: When controlling for all other predictors, 1 dollar increases in unemployed people counts by neighborhood are associated with approximately 0.0493% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.0140%, 0.0790%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Limited Subway Access: When controlling for all other predictors, a neighborhood with limited access to subway transit is expected to have approximately 125.753% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (51.508%, 269.541%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Satisfactory Subway Access: When controlling for all other predictors, a neighborhood with satisfactory access to subway transit is expected to have approximately 136.342% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (44.081%, 282.669%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Excellent Subway Access: When controlling for all other predictors, a neighborhood with excellent access to subway transit is expected to have approximately 98.186% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (15.762%, 275.969%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Food Vendor Count: When controlling for all other predictors, 1 store increases in the number of food vendors by neighborhood are associated with approximately 0.759% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.261%, 1.469%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Bus Stop Count: When controlling for all other predictors, 1 stop increases in the number of bus stop by neighborhood are associated with approximately 0.6516973% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.0402706%, 1.1496164%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Eviction Count: When controlling for all other predictors, increases in the number of evictions by neighborhood are associated with approximately 0.340% decreases in the white population count. However, there is a 95% chance that the relationship may be any value between (-0.425%, -0.248%), indicating that there is almost certainly a negative relationship between these two variables, but its magnitude may vary.
>
> If we intended to essentialize this list, `transportation_desert_4`, `eviction_count`, `store_count` seem to be the most informative predictors.






# Assault Models

## Models 1 & 2: Non-Hierarchical

> We use poisson and negative binomial regression to model observed assault counts, $i$, using our $k=10$ predictors:
>
- gini
- mean_income
- white_count
- black_count
- latinx_count
- asian_count
- mean_rent
- unemployment_count
- sub_count
- transportation_desert_4cat
- school_count
- store_count
- bus_count
- eviction_count
- uninsured_count
>
>

### Poisson {-}

$$\begin{split}
\text{White}_{i} \mid  \beta_{0}, \beta_1, ..., \beta_k & \sim \text{Pois}(\lambda_{i}) \; \; \; \; \text{where} \log(\lambda_{i}) = \beta_{0} + \sum^{10}_{k=1}X_{ik}\beta_k \\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
\end{split}$$

```{r}
poisson_non_hierarchical <- stan_glm(
  assault_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count,
  data = nyc_clean,
  family = poisson,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
```

```{r, fig.width=12, fig.height=6}
pp_check(poisson_non_hierarchical) + 
  xlab("Felon Assault Count") +
  xlim(0,max(nyc_clean$assault_count))+
  labs(title = "Poisson")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

library(kableExtra)
nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_poisson <-  posterior_predict(
  poisson_non_hierarchical, newdata = nyc_predict_clean)

library(tidybayes)
library(bayesplot)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_poisson,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
  xaxis_text(angle = 90, hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(poisson_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8) %>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchical Poisson - Model Summary") %>% 
  kable_styling()
```

### Negative Binomial {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k, r & \sim \text{NegBin}(\mu_{ij}, r) \; \; \; \; \text{where} \log(\mu_{i}) = \beta_{0} + \sum^{11}_{k=1}X_{ik}\beta_k \\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
r & \sim Exp(1) \\
\end{split}$$

```{r, cache=TRUE}
negbin_non_hierarchical <- stan_glm(
 assault_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count,
  data = nyc_clean,
  family = neg_binomial_2,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
  
```

```{r, fig.width=12, fig.height=6}
pp_check(negbin_non_hierarchical) + 
  xlab("Felony Assualt Count") +
  xlim(0,max(nyc_clean$assault_count))+
  labs(title = "Negative Binomial")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_negbin <-  posterior_predict(
  negbin_non_hierarchical, newdata = nyc_predict_clean)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_negbin,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
	xaxis_text(angle = 90,  hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())
tidy(negbin_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```


```{r}
table1 <- prediction_summary(model=poisson_non_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Poisson")
table2 <- prediction_summary(model=negbin_non_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Negative Binomial")
```

> Negative binomial has much better error metrics.


## Models 2 & 3: Hierarchy by Borough

> We use poisson and negative binomial hierarchical regression to model observed white counts, $i$, by boroughs $j$, usin our $k=11$ predictors. Note we are creating 3 dummy variables associated with `transportation_desert_4cat`:
>
- mean_income
- mean_rent
- unemployment_count
- transportation_desert_4cat
- school_count
- store_count
- bus_count
- eviction_count
- uninsured_count
>
>

### Poisson {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k & \sim \text{Pois}(\lambda_{ij}) \\
& \text{where} \log(\lambda_{ij}) = \beta_{0j} + \sum^{11}_{k=1}X_{ijk}\beta_k \\
\beta_{0j} \mid \beta_0, \sigma_0 & \stackrel{ind}{\sim} N(\beta_0, \sigma_0^2)\\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
\sigma_0 & \sim Exp(1)
\end{split}$$

```{r}
poisson_hierarchical <- stan_glmer(
  assault_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count + (1 | borough),
  data = nyc_clean,
  family = poisson,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
```

```{r, fig.width=12, fig.height=6}
pp_check(poisson_hierarchical) + 
  xlab("Felony Assault Count") +
  xlim(0,max(nyc_clean$assault_count))+
  labs(title = "Poisson")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

library(kableExtra)

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_poisson <-  posterior_predict(
  poisson_hierarchical, newdata = nyc_predict_clean)

library(tidybayes)
library(bayesplot)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_poisson,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
  xaxis_text(angle = 90, hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(poisson_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8) %>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Hierarchicahl Poisson - Model Summary") %>% 
  kable_styling()

```

### Negative Binomial {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k, r & \sim \text{NegBin}(\mu_{ij}, r) \\
& \text{where} \log(\mu_{ij}) = \beta_{0j} + \sum^{11}_{k=1}X_{ijk}\beta_k \\
\beta_{0j} \mid \beta_0, \sigma_0 & \stackrel{ind}{\sim} N(\beta_0, \sigma_0^2)\\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
r & \sim Exp(1) \\
\sigma_0 & \sim Exp(1)
\end{split}$$

```{r,  cache=TRUE}
negbin_hierarchical <- stan_glmer(
assault_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count+ (1 | borough),
  data = nyc_clean,
  family = neg_binomial_2,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0)
```

```{r, fig.width=12, fig.height=6}
pp_check(negbin_hierarchical) + 
  xlab("Felony Assault Count") +
  xlim(0,max(nyc_clean$assault_count))+
  labs(title = "Negative Binomial")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_negbin <-  posterior_predict(
  negbin_hierarchical, newdata = nyc_predict_clean)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_negbin,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
	xaxis_text(angle = 90,  hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(negbin_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```


## Models 4 & 5: Spatial

```{r}
col_sp <- as(nyc_clean, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure
moran.mc(col_sp$assault_count, listw = col_listw, nsim = 999, alternative = "greater")
```

### Poisson

```{r, fig.height=8, fig.width=8}
col_sp <- as(nyc_clean, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure

M.burnin <- 10000       # Number of burn-in iterations (discarded)
M <- 1000               # Number of iterations retained


model.assault <- S.CARleroux(
  assault_count ~ 1 + gini  + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count +  eviction_count + uninsured_count, 
  data = nyc_clean, 
  family = "poisson",
  W = W,
  burnin = M.burnin,
  n.sample = M.burnin + M,    # Total iterations
  verbose = FALSE)

as.data.frame(model.assault$summary.results) %>% 
  rownames_to_column("term") %>%
  kable()%>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "200px")

  
p_plot <- round((moran.mc(x = as.vector(model.assault$residuals$response), listw = col_listw, nsim = 9999, alternative = "greater")$p.value),5)
  

nyc_clean %>%
  mutate(resid = model.assault$residuals$response) %>%
  ggplot(aes(fill = resid), color = "#8f98aa") +
  geom_sf()+
  scale_fill_gradientn(colors=c("#fef6ef","#f07f9b","#e94a7c","#d61760"), guide =
                         guide_legend(title = "Residual")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle(paste0("1st and Degree Felony Assault: \nPoisson Model Residuals (", p_plot, ")"))+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 25, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))


```




### Zero-Inflated Poisson (Negative Binomial)

```{r, fig.height=8, fig.width=8}
draft <- nyc_clean

col_sp <- as(draft, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure

M.burnin <- 10000       # Number of burn-in iterations (discarded)
M <- 1000               # Number of iterations retained

model.assault <- S.CARleroux(
  assault_count ~ 1 + gini  + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count +  eviction_count + uninsured_count, 
  data = nyc_clean, 
  family = "zip",
  formula.omega = ~1,
  W = W,
  burnin = M.burnin,
  n.sample = M.burnin + M,    # Total iterations
  verbose = FALSE)

as.data.frame(model.assault$summary.results) %>% 
  rownames_to_column("term") %>%
  filter(Median != 0 ) %>%
  filter(`2.5%`	> 0 & `97.5%` > 0 | `2.5%`	< 0 & `97.5%` < 0) %>%  
  kable()%>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "200px")

  
# p_plot <- round((moran.mc(x = as.vector(model.assault$residuals$response), listw = col_listw, nsim = 9999, alternative = "greater")$p.value),5)
  

# nyc_clean %>%
#   mutate(resid = model.assault$residuals$response) %>%
#   ggplot(aes(fill = resid), color = "#8f98aa") +
#   geom_sf()+
#   scale_fill_gradientn(colors=c("#fef6ef","#f07f9b","#e94a7c","#d61760"), guide =
#                          guide_legend(title = "Residual")) +
#   theme_minimal() +
#   theme(panel.grid.major = element_line("transparent"),
#         axis.text = element_blank()) +
#   ggtitle(paste0("1st and Degree Felony Assault: \nZIP Model Residuals (", p_plot, ")"))+ 
#     theme(panel.grid.major = element_line("transparent"),
#           plot.title = element_text(size = 25, face = "bold"),
#           legend.title = element_text(size = 12), 
#           legend.text = element_text(size = 12)) + 
#     guides(shape = guide_legend(override.aes = list(size = 8)),
#            color = guide_legend(override.aes = list(size = 8)))

```







## Comparison

```{r}
table3 <- prediction_summary(model=poisson_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Hierarchichal Poisson")
table4 <- prediction_summary(model=negbin_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Hierarchichal Negative Binomial") 

rbind(table1, table2, table3, table4) %>%
  dplyr::mutate(model = Model, .before=1) %>%
  dplyr::select(-Model)%>% kable() %>% kable_styling()
```

> Using in-sample scaled MAE, it's evident our negative binomial regression models, regardless of hierarchy, performed better than our poisson regression models. However, the differences between the two negative binomial models was neglible. So, we will more closely interpret the non-hierarchichal negative binomial regression model.

```{r}
tidy(negbin_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```

>After removing predictors whose 95% credible intervals included the possibility of non-effect when controlling for other covariates, we found that there were 6 remaining predictors of an arbitrary neighborhood's felony assault counts:
>
- Mean income by neighborhood
- Unemployment counts by neighborhood
- Transportation desert status by neighborhood
- Food Vendor counts by neighborhood
- Bus station counts by neighborhood
- Eviction counts by neighborhood.
>
Next, we interpret each predictor:
>
- Mean Income: When controlling for all other predictors, 1 dollar increases in mean neighborhood rental prices are associated with approximately 0.00143% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.000330%, 0.00268%), indicating that there is almost certainly a negative relationship between these two variables, but its magnitude may vary.
- Unemployment Count: When controlling for all other predictors, 1 dollar increases in unemployed people counts by neighborhood are associated with approximately 0.0493% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.0140%, 0.0790%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Limited Subway Access: When controlling for all other predictors, a neighborhood with limited access to subway transit is expected to have approximately 125.753% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (51.508%, 269.541%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Satisfactory Subway Access: When controlling for all other predictors, a neighborhood with satisfactory access to subway transit is expected to have approximately 136.342% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (44.081%, 282.669%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Excellent Subway Access: When controlling for all other predictors, a neighborhood with excellent access to subway transit is expected to have approximately 98.186% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (15.762%, 275.969%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Food Vendor Count: When controlling for all other predictors, 1 store increases in the number of food vendors by neighborhood are associated with approximately 0.759% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.261%, 1.469%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Bus Stop Count: When controlling for all other predictors, 1 stop increases in the number of bus stop by neighborhood are associated with approximately 0.6516973% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.0402706%, 1.1496164%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Eviction Count: When controlling for all other predictors, increases in the number of evictions by neighborhood are associated with approximately 0.340% decreases in the white population count. However, there is a 95% chance that the relationship may be any value between (-0.425%, -0.248%), indicating that there is almost certainly a negative relationship between these two variables, but its magnitude may vary.
>
> If we intended to essentialize this list, `transportation_desert_4`, `eviction_count`, `store_count` seem to be the most informative predictors.



# Sex-Violence Models

## Models 1 & 2: Non-Hierarchical

> We use poisson and negative binomial regression to model observed assault counts, $i$, using our $k=10$ predictors:
>
- gini
- mean_income
- white_count
- black_count
- latinx_count
- asian_count
- mean_rent
- unemployment_count
- sub_count
- transportation_desert_4cat
- school_count
- store_count
- bus_count
- eviction_count
- uninsured_count
>
>

### Poisson {-}

$$\begin{split}
\text{White}_{i} \mid  \beta_{0}, \beta_1, ..., \beta_k & \sim \text{Pois}(\lambda_{i}) \; \; \; \; \text{where} \log(\lambda_{i}) = \beta_{0} + \sum^{10}_{k=1}X_{ik}\beta_k \\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
\end{split}$$

```{r}
poisson_non_hierarchical <- stan_glm(
  sex_crime_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count,
  data = nyc_clean,
  family = poisson,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
```

```{r, fig.width=12, fig.height=6}
pp_check(poisson_non_hierarchical) + 
  xlab("Sex-Based Crimes Count") +
  xlim(0,max(nyc_clean$sex_crime_count))+
  labs(title = "Poisson")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

library(kableExtra)
nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_poisson <-  posterior_predict(
  poisson_non_hierarchical, newdata = nyc_predict_clean)

library(tidybayes)
library(bayesplot)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_poisson,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
  xaxis_text(angle = 90, hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(poisson_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8) %>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchical Poisson - Model Summary") %>% 
  kable_styling()
```

### Negative Binomial {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k, r & \sim \text{NegBin}(\mu_{ij}, r) \; \; \; \; \text{where} \log(\mu_{i}) = \beta_{0} + \sum^{11}_{k=1}X_{ik}\beta_k \\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
r & \sim Exp(1) \\
\end{split}$$

```{r, cache=TRUE}
negbin_non_hierarchical <- stan_glm(
 sex_crime_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count,
  data = nyc_clean,
  family = neg_binomial_2,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
  
```

```{r, fig.width=12, fig.height=6}
pp_check(negbin_non_hierarchical) + 
  xlab("Sex-Based Crime Count") +
  xlim(0,max(nyc_clean$sex_crime_count))+
  labs(title = "Negative Binomial")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_negbin <-  posterior_predict(
  negbin_non_hierarchical, newdata = nyc_predict_clean)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_negbin,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
	xaxis_text(angle = 90,  hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())
tidy(negbin_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```


```{r}
table1 <- prediction_summary(model=poisson_non_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Poisson")
table2 <- prediction_summary(model=negbin_non_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Negative Binomial")
```

> Negative binomial has much better error metrics.


## Models 2 & 3: Hierarchy by Borough

> We use poisson and negative binomial hierarchical regression to model observed white counts, $i$, by boroughs $j$, usin our $k=11$ predictors. Note we are creating 3 dummy variables associated with `transportation_desert_4cat`:
>
- mean_income
- mean_rent
- unemployment_count
- transportation_desert_4cat
- school_count
- store_count
- bus_count
- eviction_count
- uninsured_count
>
>

### Poisson {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k & \sim \text{Pois}(\lambda_{ij}) \\
& \text{where} \log(\lambda_{ij}) = \beta_{0j} + \sum^{11}_{k=1}X_{ijk}\beta_k \\
\beta_{0j} \mid \beta_0, \sigma_0 & \stackrel{ind}{\sim} N(\beta_0, \sigma_0^2)\\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
\sigma_0 & \sim Exp(1)
\end{split}$$

```{r}
poisson_hierarchical <- stan_glmer(
  sex_crime_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count + (1 | borough),
  data = nyc_clean,
  family = poisson,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0
)
```

```{r, fig.width=12, fig.height=6}
pp_check(poisson_hierarchical) + 
  xlab("Sex-Based Crime Count") +
  xlim(0,max(nyc_clean$sex_crime_count))+
  labs(title = "Poisson")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

library(kableExtra)

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_poisson <-  posterior_predict(
  poisson_hierarchical, newdata = nyc_predict_clean)

library(tidybayes)
library(bayesplot)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_poisson,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
  xaxis_text(angle = 90, hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(poisson_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8) %>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Hierarchicahl Poisson - Model Summary") %>% 
  kable_styling()

```

### Negative Binomial {-}

$$\begin{split}
\text{White}_{ij} \mid  \beta_{0j}, \beta_1, ..., \beta_k, r & \sim \text{NegBin}(\mu_{ij}, r) \\
& \text{where} \log(\mu_{ij}) = \beta_{0j} + \sum^{11}_{k=1}X_{ijk}\beta_k \\
\beta_{0j} \mid \beta_0, \sigma_0 & \stackrel{ind}{\sim} N(\beta_0, \sigma_0^2)\\
\beta_{0c} & \sim N(0,2.5^2)\\
\beta_1 &\sim N(0, 0.0000738^2)\\
\beta_2 &\sim N(0, 0.00537^2)\\
\beta_3 &\sim N(0, 0.00298^2)\\
\beta_4 &\sim N(0, 5.281^2)\\
\beta_5 &\sim N(0, 5.375^2)\\
\beta_6 &\sim N(0, 6.7192^2)\\
\beta_7 &\sim N(0, 0.390^2)\\
\beta_8 &\sim N(0, 0.0633^2)\\
\beta_9 &\sim N(0, 0.0714^2)\\
\beta_{10} &\sim N(0, .00985^2)\\
\beta_{11} &\sim N(0, .00115^2)\\
r & \sim Exp(1) \\
\sigma_0 & \sim Exp(1)
\end{split}$$

```{r,  cache=TRUE}
negbin_hierarchical <- stan_glmer(
sex_crime_count ~ gini + mean_income + mean_rent + 
    unemployment_count + white_count + black_count + latinx_count + asian_count+
    transportation_desert_4cat + school_count + 
    store_count + bus_count + 
    eviction_count + uninsured_count+ (1 | borough),
  data = nyc_clean,
  family = neg_binomial_2,
  chains = 2, iter = 100*2, seed = 84735, refresh = 0)
```

```{r, fig.width=12, fig.height=6}
pp_check(negbin_hierarchical) + 
  xlab("Sex-Based Crime Count") +
  xlim(0,max(nyc_clean$sex_crime_count))+
  labs(title = "Negative Binomial")+
  theme(plot.title =  element_text(face="bold", size=25, hjust=.5)) 

nyc_predict_clean <- nyc_clean %>%
  na.omit()
set.seed(84735)

predictions_negbin <-  posterior_predict(
  negbin_hierarchical, newdata = nyc_predict_clean)

ppc_intervals(nyc_predict_clean$white_count, yrep = predictions_negbin,
              prob_outer = 0.8) +
  ggplot2::scale_x_continuous(
    labels = nyc_predict_clean$nta_id,
    breaks = 1:nrow(nyc_predict_clean)) +
	xaxis_text(angle = 90,  hjust = 1) +
  theme_linedraw()+
  theme(panel.grid.major = element_line("transparent"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank())

tidy(negbin_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```



## Models 4 & 5: Spatial

```{r}
col_sp <- as(nyc_clean, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure
moran.mc(col_sp$sex_crime_count, listw = col_listw, nsim = 999, alternative = "greater")
```

### Poisson

```{r, fig.height=8, fig.width=8}
col_sp <- as(nyc_clean, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure

M.burnin <- 10000       # Number of burn-in iterations (discarded)
M <- 1000               # Number of iterations retained


model.sex <- S.CARleroux(
  sex_crime_count ~ 1 + total_pop + gini + below_poverty_line_count, 
  data = nyc_clean, 
  family = "poisson",
  W = W,
  burnin = M.burnin,
  n.sample = M.burnin + M,    # Total iterations
  verbose = FALSE)

as.data.frame(model.sex$summary.results) %>% 
  rownames_to_column("term") %>%
  kable()%>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "200px")

  
p_plot <- round((moran.mc(x = as.vector(model.sex$residuals$response), listw = col_listw, nsim = 9999, alternative = "greater")$p.value),5)
  

nyc_clean %>%
  mutate(resid = model.sex$residuals$response) %>%
  ggplot(aes(fill = resid), color = "#8f98aa") +
  geom_sf()+
  scale_fill_gradientn(colors=c("#fef6ef","#f07f9b","#e94a7c","#d61760"), guide =
                         guide_legend(title = "Residual")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
  ggtitle(paste0("Sex-Based Violence: \nPoisson Model Residuals (", p_plot, ")"))+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 25, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

```




### Zero-Inflated Poisson (Negative Binomial)

```{r, fig.height=8, fig.width=8}
col_sp <- as(nyc_clean, "Spatial")
col_nb <- poly2nb(col_sp) # queen neighborhood
col_listw <- nb2listw(col_nb, style = "B") # listw version of the neighborhood
W <- nb2mat(col_nb, style = "B") # binary structure

M.burnin <- 10000       # Number of burn-in iterations (discarded)
M <- 1000               # Number of iterations retained


model.sex <- S.CARleroux(
  sex_crime_count ~ 1 + total_pop + gini + below_poverty_line_count, 
  data = nyc_clean, 
  family = "zip",
  formula.omega = ~1,
  W = W,
  burnin = M.burnin,
  n.sample = M.burnin + M,    # Total iterations
  verbose = FALSE)

as.data.frame(model.sex$summary.results) %>% 
  rownames_to_column("term") %>%
  kable()%>% 
  kable_styling() %>% 
  scroll_box(width = "100%", height = "200px")

  
p_plot <- round((moran.mc(x = as.vector(model.sex$residuals$response), listw = col_listw, nsim = 9999, alternative = "greater")$p.value),5)
  

nyc_clean %>%
  mutate(resid = model.sex$residuals$response) %>%
  ggplot(aes(fill = resid), color = "#8f98aa") +
  geom_sf()+
  scale_fill_gradientn(colors=c("#fef6ef","#f07f9b","#e94a7c","#d61760"), guide =
                         guide_legend(title = "Residual")) +
  theme_minimal() +
  theme(panel.grid.major = element_line("transparent"),
        axis.text = element_blank()) +
ggtitle(paste0("Sex-Based Violence: \nZIP Model Residuals (", p_plot, ")"))+ 
    theme(panel.grid.major = element_line("transparent"),
          plot.title = element_text(size = 25, face = "bold"),
          legend.title = element_text(size = 12), 
          legend.text = element_text(size = 12)) + 
    guides(shape = guide_legend(override.aes = list(size = 8)),
           color = guide_legend(override.aes = list(size = 8)))

```




## Comparison

```{r}
table3 <- prediction_summary(model=poisson_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Hierarchichal Poisson")
table4 <- prediction_summary(model=negbin_hierarchical, data=nyc_clean %>% na.omit())%>% 
  mutate(Model = "Hierarchichal Negative Binomial") 

rbind(table1, table2, table3, table4) %>%
  dplyr::mutate(model = Model, .before=1) %>%
  dplyr::select(-Model)%>% kable() %>% kable_styling()
```

Using in-sample scaled MAE, it's evident our negative binomial regression models, regardless of hierarchy, performed better than our poisson regression models. However, the differences between the two negative binomial models was neglible. So, we will more closely interpret the non-hierarchichal negative binomial regression model.

```{r}
tidy(negbin_non_hierarchical, effects = "fixed", conf.int = TRUE, conf.level = 0.8)%>% 
  
  mutate(estimate= ifelse(term == "(Intercept)", exp(estimate), (exp(estimate)-1)*100), 
         conf.low= ifelse(term == "(Intercept)", exp(conf.low), (exp(conf.low)-1)*100), 
         conf.high = ifelse(term == "(Intercept)", exp(conf.high), (exp(conf.high)-1)*100))%>%
  filter(conf.low	> 0 & conf.high > 0 | conf.low	< 0 & conf.high < 0) %>%
  kable(align = "c", caption = "Non-Hierarchichal Negative Binomial - Model Summary") %>% 
  kable_styling()
```

> After removing predictors whose 95% credible intervals included the possibility of non-effect when controlling for other covariates, we found that there were 6 remaining predictors of an arbitrary neighborhood's sex-based crime counts:
>
- Mean income by neighborhood
- Unemployment counts by neighborhood
- Transportation desert status by neighborhood
- Food Vendor counts by neighborhood
- Bus station counts by neighborhood
- Eviction counts by neighborhood.
>
Next, we interpret each predictor:
>
- Mean Income: When controlling for all other predictors, 1 dollar increases in mean neighborhood rental prices are associated with approximately 0.00143% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.000330%, 0.00268%), indicating that there is almost certainly a negative relationship between these two variables, but its magnitude may vary.
- Unemployment Count: When controlling for all other predictors, 1 dollar increases in unemployed people counts by neighborhood are associated with approximately 0.0493% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.0140%, 0.0790%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Limited Subway Access: When controlling for all other predictors, a neighborhood with limited access to subway transit is expected to have approximately 125.753% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (51.508%, 269.541%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Satisfactory Subway Access: When controlling for all other predictors, a neighborhood with satisfactory access to subway transit is expected to have approximately 136.342% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (44.081%, 282.669%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Excellent Subway Access: When controlling for all other predictors, a neighborhood with excellent access to subway transit is expected to have approximately 98.186% greater white population counts than a neighborhood with no subway access at all. Further, there is a 95% probability that the relationship may be any value between (15.762%, 275.969%), indicating that there is almost certainly an increase in white population counts between these two neighborhoods, but it's explicit magnitude may vary.
- Food Vendor Count: When controlling for all other predictors, 1 store increases in the number of food vendors by neighborhood are associated with approximately 0.759% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.261%, 1.469%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Bus Stop Count: When controlling for all other predictors, 1 stop increases in the number of bus stop by neighborhood are associated with approximately 0.6516973% changes in the white population count. However, there is a 95% chance that the relationship may be any value between (0.0402706%, 1.1496164%), indicating that there is almost certainly a positive relationship between these two variables, but its magnitude may vary.
- Eviction Count: When controlling for all other predictors, increases in the number of evictions by neighborhood are associated with approximately 0.340% decreases in the white population count. However, there is a 95% chance that the relationship may be any value between (-0.425%, -0.248%), indicating that there is almost certainly a negative relationship between these two variables, but its magnitude may vary.
>
> If we intended to essentialize this list, `transportation_desert_4`, `eviction_count`, `store_count` seem to be the most informative predictors.




# Next Steps

> We intend to adjust our model specifications and reconsider the construction and inclusion of our predictors. For example, we may want to rethink how we're making our transit-access variable, whether including car ownership or transit use, and what predictors we're specifically using in our models.
>
> Moving forward, we want to build some non-hierarchical models predicting subway and bus count using the demographic data (like median income, rent, percentage white population, etc) to see the flip-side of what we are looking at right now with our models above. 
>
> Our current hierarchical models attempt to capture a spatial interaction by borough, but we may extend this hierarchy to do census-tracts within neighborhoods, so as to unnderstand observed differences at a finer level. Further, we may include latitude and longitude variables into our non-grouped model to account for spatial relationships and avoid hierarchy altogether. However, we may use `CARBayes` to adjust for the spatial factors.


\
\
\
\
\
\

# Participation

>
- **Sam Ding**: Pulled and prepared subway ridership and access data, then harmonized transit data with existing neighborhood data. 
- **Vichy Meas**: Helped clean both transit and demographic data, scaffolded the checkpoint 3 responses, and helped plan out transit questions. 
- **Freddy Barragan**: Pulled and prepared grocery, bus stop, school, eviction, and census data, made exploratory visualizations by neighborhood, built/coded our proposed demographic models.
- **Juthi Dewan**: Harmonized, cleaned, and joined all disparate datasets, prepared our data summaries, built/coded our proposed demographic models.


